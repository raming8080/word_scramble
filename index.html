<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spelling Word Scramble Game</title>
    <link rel="stylesheet" href="styles.css"> <!-- Link to external CSS file -->
</head>
<body>

    <div id="game-area">
        <h1>Spelling Word Scramble Game</h1>
        <div id="stats-bar" class="stats">
            <span id="total-correct">Correct: 0</span>
            <span id="total-incorrect">Incorrect: 0</span>
            <span id="total-accuracy">Accuracy: 0%</span>
            <span id="current-word-stats">Word: 0/0</span>
            <span id="current-difficulty" class="badge">unseen</span>
            <button id="reset-stats" class="button small">Reset Stats</button>
        </div>
        <div id="scrambled-word" class="word"></div>
        <div id="user-input" class="word"></div>
        <button id="submit-button" class="button">Submit</button>
        <div id="animation" class="hidden">Correct!</div>
    </div>

    <script>
        let words = [];
        let currentWord = '';
        let scrambled = '';
        let userSelection = [];
        let gameOver = false;

        // Simple localStorage-backed per-word stats
        const STATS_KEY = 'ws_stats_v1';
        let stats = loadStats();

        function loadStats() {
            try {
                const raw = localStorage.getItem(STATS_KEY);
                if (!raw) return {};
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch (e) {
                console.warn('Failed to load stats, resetting.', e);
                return {};
            }
        }

        function saveStats() {
            try {
                localStorage.setItem(STATS_KEY, JSON.stringify(stats));
            } catch (e) {
                console.warn('Failed to save stats', e);
            }
        }

        function getWordStats(word) {
            if (!stats[word]) stats[word] = { correct: 0, incorrect: 0 };
            return stats[word];
        }

        function recordResult(word, isCorrect) {
            const ws = getWordStats(word);
            if (isCorrect) ws.correct += 1; else ws.incorrect += 1;
            saveStats();
            updateStatsUI();
            // Mark game over if all words have become easy
            if (allWordsEasy()) {
                gameOver = true;
            }
        }

        function totals() {
            let correct = 0, incorrect = 0;
            for (const w of Object.keys(stats)) {
                correct += stats[w].correct || 0;
                incorrect += stats[w].incorrect || 0;
            }
            const attempts = correct + incorrect;
            const acc = attempts ? Math.round((correct / attempts) * 100) : 0;
            return { correct, incorrect, attempts, accuracyPct: acc };
        }

        function classifyWord(word) {
            const ws = getWordStats(word);
            const attempts = ws.correct + ws.incorrect;
            if (attempts === 0) return 'unseen';
            const accuracy = attempts ? ws.correct / attempts : 0;
            if (attempts >= 3 && accuracy >= 0.8) return 'easy';
            if (attempts >= 2 && accuracy < 0.6) return 'hard';
            if (ws.incorrect >= 2 && ws.correct === 0) return 'hard';
            return 'neutral';
        }

        function pickNextWord() {
            // Prefer hard and unseen, avoid easy when possible
            const hard = words.filter(w => classifyWord(w) === 'hard');
            const unseen = words.filter(w => classifyWord(w) === 'unseen');
            const neutral = words.filter(w => classifyWord(w) === 'neutral');
            const easy = words.filter(w => classifyWord(w) === 'easy');

            let pool = [];
            if (hard.length) {
                pool = hard.concat(unseen); // heavy focus on hard+unseen
            } else if (unseen.length) {
                pool = unseen.concat(neutral);
            } else if (neutral.length) {
                pool = neutral; // avoid easy if we can
            } else {
                pool = easy.length ? easy : words; // fallback to easy or all
            }

            const idx = Math.floor(Math.random() * pool.length);
            return pool[idx];
        }

        function updateStatsUI() {
            const { correct, incorrect, accuracyPct } = totals();
            document.getElementById('total-correct').textContent = `Correct: ${correct}`;
            document.getElementById('total-incorrect').textContent = `Incorrect: ${incorrect}`;
            document.getElementById('total-accuracy').textContent = `Accuracy: ${accuracyPct}%`;

            if (currentWord) {
                const ws = getWordStats(currentWord);
                const attempts = ws.correct + ws.incorrect;
                document.getElementById('current-word-stats').textContent = `Word: ${ws.correct}/${attempts}`;
                const diff = classifyWord(currentWord);
                const badge = document.getElementById('current-difficulty');
                badge.textContent = diff;
                badge.className = `badge ${diff}`;
            }
        }

        function allWordsEasy() {
            return words.length > 0 && words.every(w => classifyWord(w) === 'easy');
        }

        function goToSummary() {
            window.location.href = 'summary.html';
        }

        // Function to fetch words from wordlist.txt
        async function fetchWords() {
            try {
                const response = await fetch('wordlist.txt');
                const text = await response.text();
                words = text.split('\n').map(word => word.trim().toLowerCase()).filter(word => word.length > 0);
                nextWord();
            } catch (error) {
                console.error('Error fetching word list:', error);
            }
        }

        // Function to shuffle letters of a word
        function shuffle(word) {
            console.log("Shuffling word:", word);
            const letters = word.split('');
            for (let i = letters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [letters[i], letters[j]] = [letters[j], letters[i]];
            }
            const shuffledWord = letters.join('');
            console.log("Shuffled word:", shuffledWord);
            return shuffledWord;
        }

        // Function to display the next scrambled word
        function nextWord() {
            currentWord = pickNextWord();
            console.log("Selected word:", currentWord);
            scrambled = shuffle(currentWord);
            displayScrambledWord();
            userSelection = [];
            updateUserInputDisplay();
            document.getElementById('animation').classList.add('hidden');
            updateStatsUI();
        }

        // Function to display scrambled word as clickable letters
        function displayScrambledWord() {
            const scrambledWordDiv = document.getElementById('scrambled-word');
            scrambledWordDiv.innerHTML = '';
            scrambled.split('').forEach((letter, index) => {
                const letterElement = document.createElement('span');
                letterElement.textContent = letter;
                letterElement.className = 'letter';
                letterElement.dataset.index = index;
                letterElement.onclick = () => toggleLetter(index);
                scrambledWordDiv.appendChild(letterElement);
            });
        }

        // Function to handle letter selection and deselection
        function toggleLetter(index) {
            const letterIndex = userSelection.indexOf(index);
            if (letterIndex > -1) {
                // Deselect the letter
                userSelection.splice(letterIndex, 1);
            } else {
                // Select the letter
                userSelection.push(index);
            }
            updateScrambledWordDisplay();
            updateUserInputDisplay();
        }

        // Function to update the scrambled word display
        function updateScrambledWordDisplay() {
            const scrambledLetters = document.querySelectorAll('#scrambled-word .letter');
            scrambledLetters.forEach((letter, index) => {
                // Update visibility based on selection
                letter.style.visibility = userSelection.includes(index) ? 'hidden' : 'visible';
            });
        }

        // Function to update the user input display
        function updateUserInputDisplay() {
            const userInputDiv = document.getElementById('user-input');
            userInputDiv.innerHTML = '';
            userSelection.forEach(index => {
                const letterElement = document.createElement('span');
                letterElement.textContent = scrambled[index];
                letterElement.className = 'letter';
                letterElement.dataset.index = index;
                letterElement.onclick = () => toggleLetter(index);
                userInputDiv.appendChild(letterElement);
            });
        }

        // Function to check if the input matches the original word
        function checkWord() {
            const selectedLetters = userSelection.map(i => scrambled[i]).join('');
            console.log("User input:", selectedLetters);
            console.log("Current word:", currentWord);
            const animationElement = document.getElementById('animation');
            
            if (selectedLetters.toLowerCase() === currentWord) {
                // Track correct attempt
                recordResult(currentWord, true);
                // Flash the assembled word letters green for positive feedback
                document.querySelectorAll('#user-input .letter').forEach(el => {
                    el.classList.add('flash-green');
                    el.addEventListener('animationend', () => {
                        el.classList.remove('flash-green');
                    }, { once: true });
                });

                animationElement.textContent = 'Correct!';
                animationElement.classList.remove('hidden');
                animationElement.classList.add('show-animation');

                // Remove the animation class after it ends
                animationElement.addEventListener('animationend', function() {
                    animationElement.classList.remove('show-animation');
                    animationElement.classList.add('hidden');
                }, { once: true });

                // Disable the submit button to prevent multiple submissions
                document.getElementById('submit-button').disabled = true;
                
                // Wait for 2 seconds, then either redirect to summary or continue
                setTimeout(() => {
                    if (gameOver) {
                        goToSummary();
                    } else {
                        nextWord();
                        document.getElementById('submit-button').disabled = false;
                    }
                }, 2000);
            } else {
                // Track incorrect attempt only if a full-length guess was made
                if (selectedLetters.length === currentWord.length) {
                    recordResult(currentWord, false);
                }
                // Per-letter feedback: green if correct position, red otherwise
                const userLetters = document.querySelectorAll('#user-input .letter');
                userLetters.forEach((el, i) => {
                    const selectedChar = scrambled[userSelection[i]];
                    const expectedChar = currentWord[i];
                    const isCorrect = selectedChar && expectedChar && selectedChar.toLowerCase() === expectedChar;
                    const cls = isCorrect ? 'flash-green' : 'flash-red';
                    el.classList.add(cls);
                    el.addEventListener('animationend', () => {
                        el.classList.remove(cls);
                    }, { once: true });
                });

                // Show incorrect feedback message
                animationElement.textContent = 'incorrect';
                animationElement.classList.remove('hidden');
                animationElement.classList.add('show-animation');

                // After the animation, hide message and reset only incorrect selections
                animationElement.addEventListener('animationend', function() {
                    animationElement.classList.remove('show-animation');
                    animationElement.classList.add('hidden');

                    // Keep only the correct positions in the current selection
                    const kept = [];
                    userSelection.forEach((idx, i) => {
                        const selectedChar = scrambled[idx];
                        const expectedChar = currentWord[i];
                        if (selectedChar && expectedChar && selectedChar.toLowerCase() === expectedChar) {
                            kept.push(idx);
                        }
                    });
                    userSelection = kept;
                    updateUserInputDisplay();
                    updateScrambledWordDisplay();
                }, { once: true });
            }
        }

        // Start the game by loading the word list
        fetchWords().then(() => {
            // If all words are already easy from prior session, jump to summary
            if (allWordsEasy()) {
                goToSummary();
            }
        });

        // Bind submit button via JS instead of inline onclick
        document.getElementById('submit-button').addEventListener('click', checkWord);

        // Reset stats button
        document.getElementById('reset-stats').addEventListener('click', () => {
            if (confirm('Reset all stats? This cannot be undone.')) {
                stats = {};
                saveStats();
                updateStatsUI();
            }
        });

        // Note: The submit button uses inline onclick to call checkWord().
        // Removed a redundant event listener and placeholder checkAnswer()
        // that previously forced the success animation on every click.
    </script>
</body>
</html>
